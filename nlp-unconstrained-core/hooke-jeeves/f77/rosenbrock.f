C =============================================================================
C NLP-UNCONSTRAINED-CORE/HOOKE-JEEVES/F77/ROSENBROCK.F
C =============================================================================
C NONLINEAR OPTIMIZATION ALGORITHMS MULTILANG. VERSION 0.1
C =============================================================================
C NONLINEAR PROGRAMMING ALGORITHMS AS THE (UN-)CONSTRAINED MINIMIZATION
C PROBLEMS WITH THE FOCUS ON THEIR NUMERICAL EXPRESSION USING VARIOUS
C PROGRAMMING LANGUAGES.
C
C THIS IS THE HOOKE AND JEEVES NONLINEAR UNCONSTRAINED MINIMIZATION ALGORITHM.
C =============================================================================
C COPYRIGHT (C) 2015 RADISLAV (RADIC) GOLUBTSOV

C =============================================================================
C NONLINEAR OPTIMIZATION USING THE ALGORITHM OF HOOKE AND JEEVES
C 12 FEBRUARY 1994 AUTHOR: MARK G. JOHNSON
C
C FIND A POINT X WHERE THE NONLINEAR FUNCTION F(X) HAS A LOCAL  MINIMUM.
C X IS AN N-VECTOR AND F(X) IS A SCALAR.  IN  MATHEMATICAL  NOTATION  F:
C R**N TENDS TO R**1. THE OBJECTIVE FUNCTION F() IS NOT REQUIRED  TO  BE
C CONTINUOUS. NOR DOES F() NEED TO BE DIFFERENTIABLE. THE  PROGRAM  DOES
C NOT USE OR REQUIRE DERIVATIVES OF F().
C
C THE SOFTWARE USER SUPPLIES THREE THINGS: A  SUBROUTINE  THAT  COMPUTES
C F(X), AN INITIAL 'STARTING GUESS' OF THE MINIMUM POINT X,  AND  VALUES
C FOR THE ALGORITHM CONVERGENCE PARAMETERS. THEN  THE  PROGRAM  SEARCHES
C FOR A LOCAL MINIMUM, BEGINNING FROM  THE  STARTING  GUESS,  USING  THE
C DIRECT SEARCH ALGORITHM OF HOOKE AND JEEVES.
C
C THIS  C  PROGRAM  IS  ADAPTED  FROM  THE  ALGOL  PSEUDOCODE  FOUND  IN
C 'ALGORITHM 178: DIRECT SEARCH' BY ARTHUR F. KAUPE JR.,  COMMUNICATIONS
C OF THE ACM, VOL 6. P.313 (JUNE 1963).  IT  INCLUDES  THE  IMPROVEMENTS
C SUGGESTED BY BELL AND PIKE (CACM V.9, P.684, SEPT 1966) AND  THOSE  OF
C TOMLIN AND SMITH, 'REMARK ON ALGORITHM 178' (CACM V.12). THE  ORIGINAL
C PAPER, WHICH I DON'T RECOMMEND AS HIGHLY AS THE ONE BY A.  KAUPE,  IS:
C R. HOOKE AND T. A. JEEVES, 'DIRECT SEARCH SOLUTION  OF  NUMERICAL  AND
C STATISTICAL PROBLEMS', JOURNAL OF THE ACM, VOL.8, APRIL 1961,  PP.212-
C 229.
C
C CALLING SEQUENCE:
C   INT HOOKE(NVARS, STARTPT, ENDPT, RHO, EPSILON, ITERMAX)
C     NVARS  (AN INTEGER)          THIS IS THE NUMBER OF  DIMENSIONS  IN
C                                  THE DOMAIN OF F(). IT IS  THE  NUMBER
C                                  OF COORDINATES OF THE STARTING  POINT
C                                  (AND THE MINIMUM POINT.)
C     STARTPT(AN ARRAY OF DOUBLES) THIS IS THE  USER-SUPPLIED  GUESS  AT
C                                  THE MINIMUM.
C     ENDPT  (AN ARRAY OF DOUBLES) THIS IS THE  LOCATION  OF  THE  LOCAL
C                                  MINIMUM, CALCULATED BY THE PROGRAM
C     RHO    (A DOUBLE)            THIS IS A  USER-SUPPLIED  CONVERGENCE
C                                  PARAMETER (MORE DETAIL BELOW),  WHICH
C                                  SHOULD BE SET TO A VALUE BETWEEN  0.0
C                                  AND 1.0. LARGER VALUES  OF  RHO  GIVE
C                                  GREATER PROBABILITY OF CONVERGENCE ON
C                                  HIGHLY NONLINEAR FUNCTIONS, AT A COST
C                                  OF MORE FUNCTION EVALUATIONS. SMALLER
C                                  VALUES OF RHO REDUCES THE  NUMBER  OF
C                                  EVALUATIONS (AND THE PROGRAM  RUNNING
C                                  TIME),  BUT  INCREASES  THE  RISK  OF
C                                  NONCONVERGENCE. SEE BELOW.
C     EPSILON(A DOUBLE)            THIS IS THE CRITERION FOR HALTING THE
C                                  SEARCH  FOR  A  MINIMUM.   WHEN   THE
C                                  ALGORITHM BEGINS  TO  MAKE  LESS  AND
C                                  LESS PROGRESS ON EACH  ITERATION,  IT
C                                  CHECKS THE HALTING CRITERION: IF  THE
C                                  STEPSIZE IS BELOW EPSILON,  TERMINATE
C                                  THE ITERATION AND RETURN THE  CURRENT
C                                  BEST ESTIMATE OF THE MINIMUM.  LARGER
C                                  VALUES OF EPSILON  (SUCH  AS  1.0E-4)
C                                  GIVE QUICKER RUNNING TIME, BUT A LESS
C                                  ACCURATE  ESTIMATE  OF  THE  MINIMUM.
C                                  SMALLER VALUES OF  EPSILON  (SUCH  AS
C                                  1.0E-7) GIVE LONGER RUNNING TIME, BUT
C                                  A  MORE  ACCURATE  ESTIMATE  OF   THE
C                                  MINIMUM.
C     ITERMAX(AN INTEGER)          A  SECOND,   RARELY   USED,   HALTING
C                                  CRITERION. IF THE ALGORITHM USES .GE.
C                                  ITERMAX ITERATIONS, HALT.
C
C THE  USER-SUPPLIED  OBJECTIVE  FUNCTION  F(X,N)  SHOULD  RETURN  A   C
C 'DOUBLE'. ITS ARGUMENTS ARE X -- AN ARRAY OF  DOUBLES,  AND  N  --  AN
C INTEGER. X IS THE POINT AT WHICH F(X) SHOULD BE EVALUATED,  AND  N  IS
C THE NUMBER  OF  COORDINATES  OF  X.  THAT  IS,  N  IS  THE  NUMBER  OF
C COEFFICIENTS BEING FITTED.
C
C   RHO, THE ALGORITHM CONVERGENCE CONTROL
C
C THE ALGORITHM WORKS BY TAKING 'STEPS' FROM ONE ESTIMATE OF A  MINIMUM,
C TO ANOTHER (HOPEFULLY BETTER) ESTIMATE. TAKING BIG STEPS GETS  TO  THE
C MINIMUM MORE  QUICKLY,  AT  THE  RISK  OF  'STEPPING  RIGHT  OVER'  AN
C EXCELLENT POINT.  THE  STEPSIZE  IS  CONTROLLED  BY  A  USER  SUPPLIED
C PARAMETER CALLED RHO. AT EACH ITERATION, THE STEPSIZE IS MULTIPLIED BY
C RHO (0 .LT. RHO .LT. 1), SO THE STEPSIZE IS SUCCESSIVELY REDUCED.
C     SMALL VALUES OF RHO CORRESPOND TO BIG STEPSIZE CHANGES, WHICH MAKE
C THE ALGORITHM RUN MORE QUICKLY. HOWEVER, THERE IS A CHANCE (ESPECIALLY
C WITH  HIGHLY  NONLINEAR  FUNCTIONS)  THAT  THESE  BIG   CHANGES   WILL
C ACCIDENTALLY  OVERLOOK  A  PROMISING   SEARCH   VECTOR,   LEADING   TO
C NONCONVERGENCE.
C     LARGE VALUES OF RHO CORRESPOND TO SMALL  STEPSIZE  CHANGES,  WHICH
C FORCE THE ALGORITHM TO CAREFULLY  EXAMINE  NEARBY  POINTS  INSTEAD  OF
C OPTIMISTICALLY  FORGING  AHEAD.  THIS  IMPROVES  THE  PROBABILITY   OF
C CONVERGENCE.
C     THE STEPSIZE IS REDUCED UNTIL IT IS EQUAL  TO  (OR  SMALLER  THAN)
C EPSILON. SO THE NUMBER OF  ITERATIONS  PERFORMED  BY  HOOKE-JEEVES  IS
C DETERMINED BY RHO AND EPSILON:
C
C   RHO ** (NUMBER_OF_ITERATIONS) = EPSILON
C
C IN GENERAL IT IS A GOOD IDEA TO SET RHO TO AN AGGRESSIVELY SMALL VALUE
C LIKE 0.5 (HOPING FOR FAST CONVERGENCE). THEN,  IF  THE  USER  SUSPECTS
C THAT THE REPORTED  MINIMUM  IS  INCORRECT  (OR  PERHAPS  NOT  ACCURATE
C ENOUGH), THE PROGRAM CAN BE RUN AGAIN WITH A LARGER VALUE OF RHO  SUCH
C AS 0.85, USING THE RESULT OF THE FIRST MINIMIZATION  AS  THE  STARTING
C GUESS TO BEGIN THE SECOND MINIMIZATION.
C
C NORMAL USE:
C   (1) CODE YOUR FUNCTION F() IN THE C LANGUAGE
C   (2) INSTALL YOUR STARTING GUESS (OR READ IT IN)
C   (3) RUN THE PROGRAM
C   (4) (FOR THE SKEPTICAL): USE THE COMPUTED MINIMUM  AS  THE  STARTING
C       POINT FOR ANOTHER RUN
C
C DATA FITTING:
C   CODE YOUR FUNCTION F() TO BE THE SUM OF THE SQUARES  OF  THE  ERRORS
C   (DIFFERENCES) BETWEEN THE COMPUTED VALUES AND THE  MEASURED  VALUES.
C   THEN MINIMIZE F() USING HOOKE-JEEVES.
C       EXAMPLE: YOU HAVE 20 DATAPOINTS (TI, YI) AND YOU  WANT  TO  FIND
C   A,B,C SUCH THAT (A * T * T) + (B * EXP(T)) + (C * TAN(T))  FITS  THE
C   DATA AS CLOSELY AS POSSIBLE. THEN F() IS JUST
C
C   F(X) = SUM(MEASURED_Y(I) - ((A * T(I) * T(I)) +
C                               (B * EXP(T(I))) +
C                               (C * TAN(T(I))))) ** 2
C
C   WHERE X() IS A 3-VECTOR CONSISTING OF (A, B, C).
C
C THE AUTHOR OF THIS SOFTWARE IS M.G. JOHNSON.
C PERMISSION TO USE, COPY, MODIFY, AND DISTRIBUTE THIS SOFTWARE FOR  ANY
C PURPOSE WITHOUT FEE IS  HEREBY  GRANTED,  PROVIDED  THAT  THIS  ENTIRE
C NOTICE IS INCLUDED IN ALL COPIES OF ANY SOFTWARE WHICH IS OR  INCLUDES
C A COPY OR MODIFICATION OF THIS SOFTWARE  AND  IN  ALL  COPIES  OF  THE
C SUPPORTING DOCUMENTATION FOR SUCH SOFTWARE.  THIS  SOFTWARE  IS  BEING
C PROVIDED  'AS  IS',  WITHOUT  ANY  EXPRESS  OR  IMPLIED  WARRANTY.  IN
C PARTICULAR, NEITHER THE AUTHOR NOR AT'N'T MAKE ANY  REPRESENTATION  OR
C WARRANTY OF ANY KIND CONCERNING THE MERCHANTABILITY OF  THIS  SOFTWARE
C OR ITS FITNESS FOR ANY PARTICULAR PURPOSE.
C =============================================================================

C     ROSENBROCK'S CLASSIC PARABOLIC VALLEY ('BANANA') FUNCTION.
      FUNCTION F(X, N)
          IMPLICIT NONE

C         MAX NUMBER OF VARIABLES.
          INTEGER VARS
          PARAMETER (VARS=250)

          DOUBLE PRECISION F
          DOUBLE PRECISION X(VARS)
          INTEGER N

C         GLOBAL VARIABLES.
          INTEGER FUNEVA
          COMMON FUNEVA

          DOUBLE PRECISION A
          DOUBLE PRECISION B
          DOUBLE PRECISION C

          FUNEVA = FUNEVA + 1
          A = X(1)
          B = X(2)
          C = 100.0 * (B - (A * A)) * (B - (A * A))

          F = C + ((1.0 - A) * (1.0 - A))
          RETURN
      END

C     GIVEN A POINT, LOOK FOR A BETTER ONE NEARBY, ONE COORD AT A TIME.
      FUNCTION BEST_N(DELTA, POINT, PREVBE, NVARS)
          IMPLICIT NONE

C         MAX NUMBER OF VARIABLES.
          INTEGER VARS
          PARAMETER (VARS=250)

          DOUBLE PRECISION BEST_N
          DOUBLE PRECISION DELTA(VARS)
          DOUBLE PRECISION POINT(VARS)
          DOUBLE PRECISION PREVBE
          INTEGER NVARS
          DOUBLE PRECISION MINF
          DOUBLE PRECISION Z(VARS)
          DOUBLE PRECISION FTMP
          INTEGER I
          DOUBLE PRECISION F

          MINF = PREVBE

          DO 10 I = 1, NVARS
              Z(I) = POINT(I)
10        CONTINUE

          DO 20 I = 1, NVARS
              Z(I) = POINT(I) + DELTA(I)
              FTMP = F(Z, NVARS)

              IF (FTMP .LT. MINF) THEN
                  MINF = FTMP
              ELSE
                  DELTA(I) = 0.0 - DELTA(I)
                  Z(I) = POINT(I) + DELTA(I)
                  FTMP = F(Z, NVARS)

                  IF (FTMP .LT. MINF) THEN
                      MINF = FTMP
                  ELSE
                      Z(I) = POINT(I)
                  END IF
              END IF
20        CONTINUE

          DO 30 I = 1, NVARS
              POINT(I) = Z(I)
30        CONTINUE

          BEST_N = MINF
          RETURN
      END

      FUNCTION HOOKE(NVARS, STARTP, ENDPT, RHO, EPSILO, ITERMA)
          IMPLICIT NONE

C         MAX NUMBER OF VARIABLES.
          INTEGER VARS
          PARAMETER (VARS=250)

          INTEGER HOOKE
          INTEGER NVARS
          DOUBLE PRECISION STARTP(VARS)
          DOUBLE PRECISION ENDPT(VARS)
          DOUBLE PRECISION RHO
          DOUBLE PRECISION EPSILO
          INTEGER ITERMA
          INTEGER I
          INTEGER IADJ
          INTEGER ITERS
          INTEGER J
          INTEGER KEEP
          DOUBLE PRECISION NEWX(VARS)
          DOUBLE PRECISION XBEFOR(VARS)
          DOUBLE PRECISION DELTA(VARS)
          DOUBLE PRECISION STEPLE
          DOUBLE PRECISION FBEFOR
          DOUBLE PRECISION NEWF
          DOUBLE PRECISION TMP

C         GLOBAL VARIABLES.
          INTEGER FUNEVA
          COMMON FUNEVA

          DOUBLE PRECISION F
          DOUBLE PRECISION BEST_N

          DO 10 I = 1, NVARS
              XBEFOR(I) = STARTP(I)
              NEWX(I) = XBEFOR(I)
              DELTA(I) = ABS(STARTP(I) * RHO)

              IF (DELTA(I) .EQ. 0.0) THEN
                  DELTA(I) = RHO
              END IF
10        CONTINUE

          IADJ = 0
          STEPLE = RHO
          ITERS = 0
          FBEFOR = F(NEWX, NVARS)
          NEWF = FBEFOR

120       IF ((ITERS .LT. ITERMA) .AND. (STEPLE .GT. EPSILO)) THEN
              ITERS = ITERS + 1
              IADJ = IADJ + 1
              PRINT 20, FUNEVA, FBEFOR
20            FORMAT (/, 'AFTER ', I5, ' FUNEVALS, F(X) =  ', 1PE11.4E3,
     *            ' AT')

              DO 30 J = 1, NVARS
                  PRINT 40, J - 1, XBEFOR(J)
40                FORMAT ('   X(', I2, ') = ', 1PE12.4E3)
30            CONTINUE

C             FIND BEST NEW POINT, ONE COORD AT A TIME.
              DO 50 I = 1, NVARS
                  NEWX(I) = XBEFOR(I)
50            CONTINUE

              NEWF = BEST_N(DELTA, NEWX, FBEFOR, NVARS)

C             IF WE MADE SOME IMPROVEMENTS, PURSUE THAT DIRECTION.
              KEEP = 1

100           IF ((NEWF .LT. FBEFOR) .AND. (KEEP .EQ. 1)) THEN
                  IADJ = 0

                  DO 60 I = 1, NVARS
C                     FIRSTLY, ARRANGE THE SIGN OF DELTA().
                      IF (NEWX(I) .LE. XBEFOR(I)) THEN
                          DELTA(I) = 0.0 - ABS(DELTA(I))
                      ELSE
                          DELTA(I) = ABS(DELTA(I))
                      END IF

C                     NOW, MOVE FURTHER IN THIS DIRECTION.
                      TMP = XBEFOR(I)
                      XBEFOR(I) = NEWX(I)
                      NEWX(I) = NEWX(I) + NEWX(I) - TMP
60                CONTINUE

                  FBEFOR = NEWF
                  NEWF = BEST_N(DELTA, NEWX, FBEFOR, NVARS)

C                 IF THE FURTHER (OPTIMISTIC) MOVE WAS BAD....
                  IF (NEWF .GE. FBEFOR) THEN
                      GO TO 70
                  END IF

C                 MAKE SURE THAT THE DIFFERENCES BETWEEN THE NEW
C                 AND THE OLD POINTS ARE DUE TO ACTUAL DISPLACEMENTS.
C                 BEWARE OF ROUNDOFF ERRORS THAT MIGHT CAUSE
C                 NEWF .LT. FBEFORE.
                  KEEP = 0

                  DO 80 I = 1, NVARS
                      KEEP = 1

                      IF (ABS(NEWX(I) - XBEFOR(I))
     *                    .GT. (0.5 * ABS(DELTA(I)))) THEN
                          GO TO 90
                      ELSE
                          KEEP = 0
                      END IF
80                CONTINUE

90                GO TO 100
70            END IF

              IF ((STEPLE .GE. EPSILO) .AND. (NEWF .GE. FBEFOR)) THEN
                  STEPLE = STEPLE * RHO

                  DO 110 I = 1, NVARS
                      DELTA(I) = DELTA(I) * RHO
110               CONTINUE
              END IF

              GO TO 120
          END IF

          DO 130 I = 1, NVARS
              ENDPT(I) = XBEFOR(I)
130       CONTINUE

          HOOKE = ITERS
          RETURN
      END

      PROGRAM ROSENB
          IMPLICIT NONE

C         MAX NUMBER OF VARIABLES.
          INTEGER VARS
          PARAMETER (VARS=250)

C         STEPSIZE GEOMETRIC SHRINK.
          DOUBLE PRECISION RHO_BE
          PARAMETER (RHO_BE=0.5)

C         ENDING VALUE OF STEPSIZE.
          DOUBLE PRECISION EPSMIN
          PARAMETER (EPSMIN=1E-6)

C         MAX NUMBER OF ITERATIONS.
          INTEGER IMAX
          PARAMETER (IMAX=5000)

C         GLOBAL VARIABLES.
          INTEGER FUNEVA
          COMMON FUNEVA

          INTEGER NVARS
          INTEGER ITERMA
          INTEGER JJ
          INTEGER I
          DOUBLE PRECISION STARTP(VARS)
          DOUBLE PRECISION RHO
          DOUBLE PRECISION EPSILO
          DOUBLE PRECISION ENDPT(VARS)
          INTEGER HOOKE

          FUNEVA = 0

C         STARTING GUESS FOR ROSENBROCK'S TEST FUNCTION.
          NVARS = 2
          STARTP(1) = -1.2
          STARTP(2) = 1.0
          ITERMA = IMAX
          RHO = RHO_BE
          EPSILO = EPSMIN
          JJ = HOOKE(NVARS, STARTP, ENDPT, RHO, EPSILO, ITERMA)
          PRINT 10, JJ
10        FORMAT (///, 'HOOKE USED ', I2, ' ITERATIONS, AND RETURNED')

          DO 20 I = 1, NVARS
              PRINT 30, I - 1, ENDPT(I)
30            FORMAT ('X(', I3, ') = ', 1PE15.7E3, ' ')
20        CONTINUE
      END

C =============================================================================
